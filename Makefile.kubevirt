# =============================================================================
# KubeVirt Local Testing Environment Makefile
# =============================================================================
# This Makefile sets up a complete local testing environment using:
# - Kind cluster (management cluster)
# - KubeVirt
# - Cluster API Provider for KubeVirt (CAPK)
# - osbuilder (for building Kairos qcow images)
# - Kairos CAPI Provider
#
# Quick Start:
#   1. Install prerequisites: make install-kind install-clusterctl
#   2. Run complete setup: make setup
#   3. Upload image: make upload-kairos-image
#   4. Create sample cluster: make create-sample-cluster
#   5. Apply cluster: kubectl apply -f config/samples/capk/kairos_cluster_k0s_single_node.yaml
#
# Workflow:
#   setup -> upload-kairos-image -> create-sample-cluster -> apply cluster manifest
#
# For detailed help: make help

# =============================================================================
# Variables
# =============================================================================

# Cluster configuration
KIND_CLUSTER_NAME ?= kairos-capi-test
KIND_CONFIG ?= hack/kind-config.yaml
KUBECONFIG ?= $(HOME)/.kube/config
DOCKER_CONFIG_PATH ?= $(HOME)/.docker/config.json

# Versions
CAPI_VERSION ?= v1.8.0
CAPK_VERSION ?= v0.1.10
KUBEVIRT_VERSION ?= v1.3.0
KIND_VERSION ?= v0.25.0
CLUSTERCTL_VERSION ?= v1.8.0
KUBECTL_VERSION ?= v1.30.0
CALICO_VERSION ?= v3.29.1

# Kairos/osbuilder configuration
OSBUILDER_REPO ?= https://github.com/kairos-io/osbuilder.git
OSBUILDER_DIR ?= $(shell pwd)/.osbuilder
KAIROS_IMAGE_NAME ?= kairos-kubevirt
KAIROS_IMAGE_VERSION ?= latest
KAIROS_IMAGE_FILE ?= $(OSBUILDER_DIR)/build/$(KAIROS_IMAGE_NAME).raw

# Kairos CAPI Provider image configuration
KAIROS_CAPI_IMG ?= ghcr.io/wrkode/kairos-capi:latest

# Directories
WORK_DIR ?= $(shell pwd)/.work
BIN_DIR ?= $(shell pwd)/bin

# Image registry (for kind)
REGISTRY_NAME ?= registry.local
REGISTRY_PORT ?= 5000
REGISTRY ?= $(REGISTRY_NAME):$(REGISTRY_PORT)

# Shell configuration
SHELL = /usr/bin/env bash -o pipefail
.SHELLFLAGS = -ec

# =============================================================================
# Phony Targets
# =============================================================================

.PHONY: help
help: ## Display this help message
	@echo "KubeVirt Local Testing Environment"
	@echo ""
	@echo "Usage: make [target]"
	@echo ""
	@echo "Main targets:"
	@awk 'BEGIN {FS = ":.*##"; printf "\n"} /^[a-zA-Z_0-9-]+:.*?##/ { printf "  \033[36m%-25s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)

##@ Setup

.PHONY: setup
setup: check-prerequisites create-kind-cluster install-calico install-kubevirt install-capi setup-osbuilder build-kairos-image import-kairos-image install-kairos-provider ## Complete setup: create cluster and install all components

.PHONY: setup-without-build
setup-without-build: check-prerequisites create-kind-cluster install-calico install-kubevirt install-capi setup-osbuilder install-kairos-provider ## Setup without building image (build separately with build-kairos-image)

.PHONY: check-prerequisites
check-prerequisites: ## Check if required tools are installed
	@echo "Checking prerequisites..."
	@command -v docker >/dev/null 2>&1 || { echo "Error: docker is required but not installed"; exit 1; }
	@command -v kubectl >/dev/null 2>&1 || { echo "Error: kubectl is required but not installed"; exit 1; }
	@command -v kind >/dev/null 2>&1 || { echo "Error: kind is required but not installed. Run 'make install-kind'"; exit 1; }
	@command -v clusterctl >/dev/null 2>&1 || { echo "Error: clusterctl is required but not installed. Run 'make install-clusterctl'"; exit 1; }
	@echo "All prerequisites met ✓"

.PHONY: install-kind
install-kind: ## Install kind
	@echo "Installing kind $(KIND_VERSION)..."
	@mkdir -p $(BIN_DIR)
	@curl -Lo $(BIN_DIR)/kind https://kind.sigs.k8s.io/dl/$(KIND_VERSION)/kind-linux-amd64
	@chmod +x $(BIN_DIR)/kind
	@sudo mv $(BIN_DIR)/kind /usr/local/bin/kind 2>/dev/null || { \
		echo "Installed to $(BIN_DIR)/kind (add $(BIN_DIR) to PATH)"; \
	}
	@echo "kind installed ✓"

.PHONY: install-clusterctl
install-clusterctl: ## Install clusterctl
	@echo "Installing clusterctl $(CLUSTERCTL_VERSION)..."
	@mkdir -p $(BIN_DIR)
	@curl -L https://github.com/kubernetes-sigs/cluster-api/releases/download/$(CLUSTERCTL_VERSION)/clusterctl-linux-amd64 -o $(BIN_DIR)/clusterctl
	@chmod +x $(BIN_DIR)/clusterctl
	@echo "clusterctl installed to $(BIN_DIR)/clusterctl"
	@echo "Add $(BIN_DIR) to your PATH or use: export PATH=$$PATH:$(BIN_DIR)"

##@ Kind Cluster

.PHONY: create-kind-cluster
create-kind-cluster: ## Create a kind cluster for testing (CNI disabled for Calico installation)
	@echo "Creating kind cluster '$(KIND_CLUSTER_NAME)'..."
	@if kind get clusters | grep -q "^$(KIND_CLUSTER_NAME)$$"; then \
		echo "Cluster '$(KIND_CLUSTER_NAME)' already exists. Use 'make delete-kind-cluster' to remove it first."; \
		exit 1; \
	fi
	@mkdir -p $(WORK_DIR)
	@if [ ! -f "$(DOCKER_CONFIG_PATH)" ]; then \
		echo "Warning: Docker config file not found at $(DOCKER_CONFIG_PATH)"; \
		echo "Creating empty Docker config to avoid rate limits..."; \
		mkdir -p $$(dirname $(DOCKER_CONFIG_PATH)); \
		echo '{}' > $(DOCKER_CONFIG_PATH); \
	fi
	@printf 'kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: %s\nnetworking:\n  disableDefaultCNI: true\nnodes:\n- role: control-plane\n  extraMounts:\n  - containerPath: /var/lib/kubelet/config.json\n    hostPath: %s\n' $(KIND_CLUSTER_NAME) $(DOCKER_CONFIG_PATH) > $(WORK_DIR)/kind-config.yaml
	@echo "Kind config created with Docker config mount: $(DOCKER_CONFIG_PATH)"
	@kind create cluster --name $(KIND_CLUSTER_NAME) --config $(WORK_DIR)/kind-config.yaml
	@kubectl cluster-info --context kind-$(KIND_CLUSTER_NAME)
	@echo "Kind cluster created ✓"
	@echo "Note: Default CNI is disabled. Install Calico with: make install-calico"

.PHONY: delete-kind-cluster
delete-kind-cluster: ## Delete the kind cluster
	@echo "Deleting kind cluster '$(KIND_CLUSTER_NAME)'..."
	@kind delete cluster --name $(KIND_CLUSTER_NAME) || true
	@echo "Kind cluster deleted ✓"

.PHONY: kind-kubeconfig
kind-kubeconfig: ## Get kubeconfig for the kind cluster
	@kind get kubeconfig --name $(KIND_CLUSTER_NAME)

.PHONY: install-calico
install-calico: ## Install Calico CNI (required for LoadBalancer support in KubeVirt)
	@echo "Installing Calico CNI $(CALICO_VERSION)..."
	@kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/$(CALICO_VERSION)/manifests/calico.yaml || \
		kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/$(CALICO_VERSION)/manifests/calico.yaml
	@echo "Waiting for Calico to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n kube-system deployment/calico-kube-controllers || true
	@echo "Waiting for Calico node daemonset pods to be ready..."
	@bash -c '\
		timeout=300; \
		while [ $$timeout -gt 0 ]; do \
			ready=$$(kubectl get daemonset calico-node -n kube-system -o jsonpath="{.status.numberReady}" 2>/dev/null || echo "0"); \
			desired=$$(kubectl get daemonset calico-node -n kube-system -o jsonpath="{.status.desiredNumberScheduled}" 2>/dev/null || echo "0"); \
			if [ "$$ready" = "$$desired" ] && [ "$$desired" != "0" ]; then \
				echo "✓ Calico node daemonset is ready ($$ready/$$desired pods)"; \
				break; \
			fi; \
			echo -n "."; \
			sleep 2; \
			timeout=$$((timeout - 2)); \
		done; \
		echo ""; \
		if [ $$timeout -le 0 ]; then \
			echo "Warning: Calico node daemonset may not be fully ready, but continuing..."; \
			kubectl get daemonset calico-node -n kube-system || true; \
		fi'
	@echo "Calico CNI installed ✓"

##@ KubeVirt

.PHONY: install-kubevirt
install-kubevirt: install-cdi ## Install KubeVirt on the kind cluster
	@echo "Installing KubeVirt $(KUBEVIRT_VERSION)..."
	@kubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/$(KUBEVIRT_VERSION)/kubevirt-operator.yaml
	@kubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/$(KUBEVIRT_VERSION)/kubevirt-cr.yaml
	@echo "Waiting for KubeVirt to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n kubevirt deployment/virt-operator || true
	@echo "Waiting for KubeVirt CR to be ready..."
	@bash -c '\
		echo "Checking KubeVirt status..."; \
		if kubectl wait --for=condition=Available --timeout=10s -n kubevirt kubevirt/kubevirt 2>/dev/null; then \
			echo "✓ KubeVirt is ready (Available condition met)"; \
		else \
			echo "Waiting for KubeVirt phase to be Deployed..."; \
			timeout=300; \
			while [ $$timeout -gt 0 ]; do \
				phase=$$(kubectl get kubevirt kubevirt -n kubevirt -o jsonpath="{.status.phase}" 2>/dev/null || echo ""); \
				if [ "$$phase" = "Deployed" ]; then \
					echo "✓ KubeVirt is ready (phase: $$phase)"; \
					break; \
				fi; \
				echo -n "."; \
				sleep 2; \
				timeout=$$((timeout - 2)); \
			done; \
			echo ""; \
			if [ $$timeout -le 0 ]; then \
				echo "Warning: KubeVirt may not be fully ready, but continuing..."; \
				kubectl get kubevirt kubevirt -n kubevirt || true; \
			fi \
		fi'
	@echo "KubeVirt installed ✓"

.PHONY: install-cdi
install-cdi: ## Install Containerized Data Importer (CDI) for image uploads
	@echo "Installing CDI (Containerized Data Importer)..."
	@kubectl apply -f https://github.com/kubevirt/containerized-data-importer/releases/latest/download/cdi-operator.yaml
	@kubectl apply -f https://github.com/kubevirt/containerized-data-importer/releases/latest/download/cdi-cr.yaml
	@echo "Waiting for CDI to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n cdi deployment/cdi-operator || true
	@echo "Waiting for CDI CR to be ready..."
	@bash -c '\
		echo "Checking CDI status..."; \
		if kubectl wait --for=condition=Available --timeout=10s -n cdi cdi/cdi 2>/dev/null; then \
			echo "✓ CDI is ready (Available condition met)"; \
		else \
			echo "Waiting for CDI phase to be Deployed..."; \
			timeout=300; \
			while [ $$timeout -gt 0 ]; do \
				phase=$$(kubectl get cdi cdi -n cdi -o jsonpath="{.status.phase}" 2>/dev/null || echo ""); \
				if [ "$$phase" = "Deployed" ]; then \
					echo "✓ CDI is ready (phase: $$phase)"; \
					break; \
				fi; \
				echo -n "."; \
				sleep 2; \
				timeout=$$((timeout - 2)); \
			done; \
			echo ""; \
			if [ $$timeout -le 0 ]; then \
				echo "Warning: CDI may not be fully ready, but continuing..."; \
				kubectl get cdi cdi -n cdi || true; \
			fi \
		fi'
	@echo "CDI installed ✓"

.PHONY: uninstall-kubevirt
uninstall-kubevirt: ## Uninstall KubeVirt from the kind cluster
	@echo "Uninstalling KubeVirt..."
	@kubectl delete -f https://github.com/kubevirt/kubevirt/releases/download/$(KUBEVIRT_VERSION)/kubevirt-cr.yaml || true
	@kubectl delete -f https://github.com/kubevirt/kubevirt/releases/download/$(KUBEVIRT_VERSION)/kubevirt-operator.yaml || true
	@echo "KubeVirt uninstalled ✓"

##@ Cluster API

.PHONY: install-capi
install-capi: ## Install Cluster API (CAPI) and CAPK on the kind cluster
	@echo "Installing Cluster API $(CAPI_VERSION) with KubeVirt provider (CAPK $(CAPK_VERSION))..."
	@export PATH=$$PATH:$(BIN_DIR) && \
	echo "Using CAPK version: $(CAPK_VERSION)" && \
	clusterctl init --infrastructure kubevirt:$(CAPK_VERSION) || \
	{ echo "Error: Failed to initialize CAPI with CAPK $(CAPK_VERSION). Make sure clusterctl is in PATH."; exit 1; }
	@echo "Waiting for CAPI components to be ready..."
	@bash -c '\
		echo "Waiting for CAPI core controller..."; \
		kubectl wait --for=condition=Available --timeout=300s -n capi-system deployment/capi-controller-manager 2>/dev/null || echo "  (CAPI core may still be starting)"; \
		echo "Waiting for CAPK bootstrap controller..."; \
		kubectl wait --for=condition=Available --timeout=300s -n capi-kubevirt-bootstrap-system deployment/capi-kubevirt-bootstrap-controller-manager 2>/dev/null || echo "  (CAPK bootstrap may still be starting)"; \
		echo "Waiting for CAPK control plane controller..."; \
		kubectl wait --for=condition=Available --timeout=300s -n capi-kubevirt-control-plane-system deployment/capi-kubevirt-control-plane-controller-manager 2>/dev/null || echo "  (CAPK control plane may still be starting)"; \
		echo "Waiting for CAPK infrastructure controller..."; \
		kubectl wait --for=condition=Available --timeout=300s -n capk-system deployment/capk-controller-manager 2>/dev/null || echo "  (CAPK infrastructure may still be starting)"; \
		echo "Note: Some controllers may still be initializing. Check with: kubectl get pods -A | grep cap"'
	@echo "Cluster API and CAPK installed ✓"

.PHONY: uninstall-capi
uninstall-capi: ## Uninstall Cluster API from the kind cluster
	@echo "Uninstalling Cluster API..."
	@export PATH=$$PATH:$(BIN_DIR) && \
	clusterctl delete --all || true
	@echo "Cluster API uninstalled ✓"

##@ CAPK (Cluster API Provider for KubeVirt)

.PHONY: install-capk
install-capk: install-capi ## Alias for install-capi (CAPK is installed with CAPI)
	@echo "CAPK is installed as part of CAPI initialization"

##@ osbuilder

.PHONY: install-helm
install-helm: ## Install Helm if not already installed
	@if command -v helm >/dev/null 2>&1; then \
		echo "Helm is already installed: $$(helm version --short)"; \
	else \
		echo "Installing Helm..."; \
		curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash || \
		{ echo "Error: Failed to install Helm. Please install it manually."; exit 1; }; \
	fi

.PHONY: install-osbuilder-crds
install-osbuilder-crds: install-helm ## Install osbuilder CRDs (OSArtifact) via Helm chart
	@echo "Installing osbuilder CRDs from Helm chart..."
	@helm repo add kairos https://kairos-io.github.io/helm-charts 2>/dev/null || helm repo add kairos https://kairos-io.github.io/helm-charts --force-update
	@helm repo update kairos
	@helm upgrade --install kairos-crds kairos/kairos-crds --namespace default --create-namespace --wait --timeout=60s || \
	{ echo "Error: Failed to install/upgrade osbuilder CRDs via Helm chart."; exit 1; }
	@echo "Waiting for OSArtifact CRD to be ready..."
	@kubectl wait --for=condition=Established --timeout=60s crd/osartifacts.build.kairos.io || \
	{ echo "Error: OSArtifact CRD not established."; exit 1; }
	@echo "osbuilder CRDs installed ✓"

.PHONY: setup-osbuilder
setup-osbuilder: install-osbuilder-crds ## Install osbuilder using Helm charts
	@echo "Installing osbuilder using Helm charts..."
	@helm repo add kairos https://kairos-io.github.io/helm-charts 2>/dev/null || helm repo add kairos https://kairos-io.github.io/helm-charts --force-update
	@helm repo update kairos
	@helm upgrade --install osbuilder kairos/osbuilder -n default --create-namespace || \
	{ echo "Error: Failed to install/upgrade osbuilder."; exit 1; }
	@echo "Waiting for osbuilder to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n default deployment/osbuilder 2>/dev/null || \
	{ echo "Warning: osbuilder deployment may still be starting. Check with: kubectl get pods -n default -l app.kubernetes.io/name=osbuilder"; }
	@echo "osbuilder installed ✓"

.PHONY: build-kairos-image
build-kairos-image: setup-osbuilder ## Build Kairos cloud image using OSArtifact CR (via Helm-installed osbuilder)
	@echo "Building Kairos cloud image using OSArtifact CR..."
	@echo "Note: osbuilder controller will create a Job to build the image."
	@echo "The built image will be served via nginx service."
	@mkdir -p $(WORK_DIR)
	@mkdir -p $(OSBUILDER_DIR)/build
	@echo "Creating cloud-config Secret with console parameters..."
	@printf '#cloud-config\n\n# Add console parameters to kernel cmdline for serial console access\n# console=ttyS0 enables serial console, console=tty0 enables VGA console\ninstall:\n  grub_options:\n    extra_cmdline: "console=ttyS0 console=tty0"\n' | kubectl create secret generic $(KAIROS_IMAGE_NAME)-cloud-config --from-file=cloud_config.yaml=/dev/stdin -n default --dry-run=client -o yaml | kubectl apply -f -
	@echo "Creating OSArtifact CustomResource..."
	@printf 'apiVersion: build.kairos.io/v1alpha2\nkind: OSArtifact\nmetadata:\n  name: %s\n  namespace: default\nspec:\n  imageName: "quay.io/kairos/fedora:40-core-amd64-generic-v3.6.1-beta2"\n  cloudImage: true\n  diskSize: "32000"\n  cloudConfigRef:\n    name: %s-cloud-config\n    key: cloud_config.yaml\n  exporters:\n  - template:\n      spec:\n        restartPolicy: Never\n        containers:\n        - name: upload\n          image: quay.io/curl/curl\n          command:\n          - /bin/sh\n          args:\n          - -c\n          - |\n              for f in $$(ls /artifacts)\n              do\n              curl -T /artifacts/$$f http://osartifactbuilder-operator-osbuilder-nginx/upload/$$f\n              done\n          volumeMounts:\n          - name: artifacts\n            mountPath: /artifacts\n' $(KAIROS_IMAGE_NAME) $(KAIROS_IMAGE_NAME) > $(WORK_DIR)/osartifact.yaml
	@kubectl apply -f $(WORK_DIR)/osartifact.yaml
	@echo "Waiting for OSArtifact to be ready..."
	@bash -c '\
		timeout=1800; \
		while [ $$timeout -gt 0 ]; do \
			phase=$$(kubectl get osartifact $(KAIROS_IMAGE_NAME) -n default -o jsonpath="{.status.phase}" 2>/dev/null || echo "Pending"); \
			if [ "$$phase" = "Ready" ]; then \
				echo "✓ OSArtifact is ready (phase: $$phase)"; \
				break; \
			elif [ "$$phase" = "Error" ]; then \
				echo "✗ OSArtifact build failed. Check logs:"; \
				kubectl get osartifact $(KAIROS_IMAGE_NAME) -n default -o yaml; \
				exit 1; \
			fi; \
			echo -n "."; \
			sleep 5; \
			timeout=$$((timeout - 5)); \
		done; \
		echo ""; \
		if [ $$timeout -le 0 ]; then \
			echo "Warning: OSArtifact build timed out. Check status:"; \
			kubectl get osartifact $(KAIROS_IMAGE_NAME) -n default; \
			exit 1; \
		fi'
	@echo "Downloading built image from nginx..."
	@bash -c '\
		ARTIFACT_NAME="$(KAIROS_IMAGE_NAME)"; \
		IMAGE_FILENAME="$$ARTIFACT_NAME.raw"; \
		NGINX_SVC=$$(kubectl get svc -n default -o jsonpath="{.items[?(@.spec.type==\"NodePort\")].metadata.name}" | tr " " "\n" | grep -i nginx | head -1); \
		if [ -z "$$NGINX_SVC" ]; then \
			echo "Error: Could not find nginx service."; \
			kubectl get svc -n default || true; \
			exit 1; \
		fi; \
		NODE_PORT=$$(kubectl get svc $$NGINX_SVC -n default -o jsonpath="{.spec.ports[0].nodePort}"); \
		NODE_IP=$$(kubectl get nodes -o jsonpath="{.items[0].status.addresses[?(@.type==\"InternalIP\")].address}"); \
		if [ -z "$$NODE_PORT" ] || [ -z "$$NODE_IP" ]; then \
			echo "Error: Could not determine nginx endpoint."; \
			exit 1; \
		fi; \
		NGINX_URL="http://$$NODE_IP:$$NODE_PORT"; \
		OUTPUT_FILE="$(OSBUILDER_DIR)/build/$$IMAGE_FILENAME"; \
		echo "Downloading $$IMAGE_FILENAME from $$NGINX_URL/$$IMAGE_FILENAME"; \
		curl -f -o "$$OUTPUT_FILE" "$$NGINX_URL/$$IMAGE_FILENAME" || \
		{ echo "Error: Failed to download image from $$NGINX_URL/$$IMAGE_FILENAME"; exit 1; }; \
		echo "Downloaded to: $$OUTPUT_FILE"'
	@echo "Checking for built image..."
	@find $(OSBUILDER_DIR)/build -name "$(KAIROS_IMAGE_NAME)*" -type f 2>/dev/null | head -5 || echo "No image files found."
	@echo "Kairos image build complete ✓"

##@ Image Import

.PHONY: import-kairos-image
import-kairos-image: ## Import Kairos image to KubeVirt as a DataVolume
	@echo "Importing Kairos image to KubeVirt..."
	@bash -c '\
		IMAGE_FILE=""; \
		if [ -f "$(KAIROS_IMAGE_FILE)" ]; then \
			IMAGE_FILE="$(KAIROS_IMAGE_FILE)"; \
		elif [ -d "$(OSBUILDER_DIR)/build" ]; then \
			IMAGE_FILE=$$(find $(OSBUILDER_DIR)/build -name "$(KAIROS_IMAGE_NAME)*" -type f \( -name "*.raw" -o -name "*.qcow2" \) | head -1); \
			if [ -z "$$IMAGE_FILE" ]; then \
				echo "Warning: No image files found in $(OSBUILDER_DIR)/build/"; \
				echo "Available files:"; \
				ls -la $(OSBUILDER_DIR)/build/ 2>/dev/null || echo "Build directory is empty."; \
				echo "Please run '\''make build-kairos-image'\'' first or specify KAIROS_IMAGE_FILE manually."; \
				exit 1; \
			fi; \
			echo "Found image: $$IMAGE_FILE"; \
		else \
			echo "Error: Image file not found and build directory doesn'\''t exist."; \
			echo "Please run '\''make build-kairos-image'\'' first to build the image."; \
			exit 1; \
		fi; \
		echo "Using image file: $$IMAGE_FILE"; \
		echo "Creating PVC for Kairos image..."; \
		printf '\''apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: %s\n  namespace: default\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 20Gi\n'\'' $(KAIROS_IMAGE_NAME) > $(WORK_DIR)/kairos-pvc.yaml; \
		kubectl apply -f $(WORK_DIR)/kairos-pvc.yaml; \
		echo "PVC created. Use '\''make upload-kairos-image'\'' to upload the image, or:"; \
		echo "  virtctl image-upload --image-path=$$IMAGE_FILE --pvc-name=$(KAIROS_IMAGE_NAME) --pvc-size=20Gi"'
	@echo "Kairos image import setup complete ✓"

.PHONY: install-virtctl
install-virtctl: ## Install virtctl CLI tool
	@echo "Installing virtctl..."
	@mkdir -p $(BIN_DIR)
	@VERSION=$$(kubectl get kubevirt kubevirt -n kubevirt -o jsonpath='{.status.observedKubeVirtVersion}' 2>/dev/null || echo "$(KUBEVIRT_VERSION)") && \
	curl -L https://github.com/kubevirt/kubevirt/releases/download/$$VERSION/virtctl-$$VERSION-linux-amd64 -o $(BIN_DIR)/virtctl && \
	chmod +x $(BIN_DIR)/virtctl && \
	echo "virtctl installed to $(BIN_DIR)/virtctl"

.PHONY: upload-kairos-image
upload-kairos-image: install-virtctl ## Upload Kairos image using virtctl
	@echo "=== Uploading Kairos image using virtctl ==="
	@bash -c '\
	set -e; \
	echo "[1/8] Checking for virtctl..."; \
	if ! command -v virtctl >/dev/null 2>&1 && [ ! -f "$(BIN_DIR)/virtctl" ]; then \
		echo "ERROR: virtctl not found in PATH or $(BIN_DIR)/virtctl"; \
		echo "Please run '\''make -f Makefile.kubevirt install-virtctl'\'' first."; \
		exit 1; \
	fi; \
	VIRTCTL_CMD=$$(command -v virtctl 2>/dev/null || echo "$(BIN_DIR)/virtctl"); \
	echo "Using virtctl: $$VIRTCTL_CMD"; \
	echo "[2/8] Locating image file..."; \
	IMAGE_FILE=""; \
	if [ -f "$(KAIROS_IMAGE_FILE)" ]; then \
		IMAGE_FILE="$(KAIROS_IMAGE_FILE)"; \
		echo "Found image at expected path: $$IMAGE_FILE"; \
	elif [ -d "$(OSBUILDER_DIR)/build" ]; then \
		IMAGE_FILE=$$(find $(OSBUILDER_DIR)/build -name "$(KAIROS_IMAGE_NAME)*" -type f \( -name "*.raw" -o -name "*.qcow2" \) | head -1); \
		if [ -n "$$IMAGE_FILE" ]; then \
			echo "Found image in build directory: $$IMAGE_FILE"; \
		fi; \
	fi; \
	if [ -z "$$IMAGE_FILE" ] || [ ! -f "$$IMAGE_FILE" ]; then \
		echo "ERROR: Image file not found."; \
		echo "Expected path: $(KAIROS_IMAGE_FILE)"; \
		if [ -d "$(OSBUILDER_DIR)/build" ]; then \
			echo "Available files in $(OSBUILDER_DIR)/build/:"; \
			ls -la $(OSBUILDER_DIR)/build/ 2>/dev/null || echo "Build directory is empty."; \
		else \
			echo "Build directory not found: $(OSBUILDER_DIR)/build"; \
			echo "Run '\''make -f Makefile.kubevirt build-kairos-image'\'' first."; \
		fi; \
		exit 1; \
	fi; \
	IMAGE_SIZE=$$(du -h "$$IMAGE_FILE" | cut -f1); \
	echo "Image file: $$IMAGE_FILE ($$IMAGE_SIZE)"; \
	echo "[3/8] Checking CDI upload proxy service..."; \
	if ! kubectl get service cdi-uploadproxy -n cdi >/dev/null 2>&1; then \
		echo "ERROR: CDI upload proxy service not found."; \
		echo "Checking CDI installation..."; \
		kubectl get pods -n cdi 2>/dev/null || echo "CDI namespace not found."; \
		echo "Make sure CDI is installed: make -f Makefile.kubevirt install-cdi"; \
		exit 1; \
	fi; \
	echo "CDI upload proxy service found. Will use port-forwarding for host access."; \
	PORT_FORWARD_PORT=$${CDI_UPLOAD_PORT:-18443}; \
	if [ -z "$$CDI_UPLOAD_PORT" ]; then \
		echo "Checking if port $$PORT_FORWARD_PORT is available..."; \
		if command -v lsof >/dev/null 2>&1; then \
			while lsof -Pi :$$PORT_FORWARD_PORT -sTCP:LISTEN -t >/dev/null 2>&1; do \
				echo "Port $$PORT_FORWARD_PORT is in use, trying next port..."; \
				PORT_FORWARD_PORT=$$((PORT_FORWARD_PORT + 1)); \
				if [ $$PORT_FORWARD_PORT -gt 18500 ]; then \
					echo "ERROR: Could not find available port between 18443-18500"; \
					echo "Please free up a port or set CDI_UPLOAD_PORT manually"; \
					exit 1; \
				fi; \
			done; \
		elif command -v ss >/dev/null 2>&1; then \
			while ss -lnt | grep -q ":$$PORT_FORWARD_PORT "; do \
				echo "Port $$PORT_FORWARD_PORT is in use, trying next port..."; \
				PORT_FORWARD_PORT=$$((PORT_FORWARD_PORT + 1)); \
				if [ $$PORT_FORWARD_PORT -gt 18500 ]; then \
					echo "ERROR: Could not find available port between 18443-18500"; \
					echo "Please free up a port or set CDI_UPLOAD_PORT manually"; \
					exit 1; \
				fi; \
			done; \
		fi; \
	fi; \
	echo "Using local port: $$PORT_FORWARD_PORT"; \
	echo "[4/5] Checking for existing DataVolume..."; \
	if kubectl get datavolume $(KAIROS_IMAGE_NAME)-upload -n default >/dev/null 2>&1; then \
		echo "DataVolume $(KAIROS_IMAGE_NAME)-upload already exists. Deleting for fresh upload..."; \
		kubectl delete datavolume $(KAIROS_IMAGE_NAME)-upload -n default --wait=true --timeout=30s 2>/dev/null || true; \
		sleep 2; \
	fi; \
	echo "[5/5] Setting up port-forward and starting upload with virtctl..."; \
	echo "virtctl will create the DataVolume and handle upload pod creation automatically."; \
	echo "Checking for existing kubectl port-forward processes on port $$PORT_FORWARD_PORT..."; \
	if command -v lsof >/dev/null 2>&1; then \
		EXISTING_PIDS=$$(lsof -ti :$$PORT_FORWARD_PORT 2>/dev/null || true); \
		if [ -n "$$EXISTING_PIDS" ]; then \
			for pid in $$EXISTING_PIDS; do \
				if ps -p $$pid -o comm= 2>/dev/null | grep -q "kubectl"; then \
					echo "Found existing kubectl port-forward (PID: $$pid), killing it..."; \
					kill $$pid 2>/dev/null || true; \
				fi; \
			done; \
			sleep 1; \
		fi; \
	fi; \
	PORT_FORWARD_LOG="/tmp/cdi-port-forward-$$$$.log"; \
	rm -f $$PORT_FORWARD_LOG; \
	kubectl port-forward -n cdi service/cdi-uploadproxy $$PORT_FORWARD_PORT:443 >$$PORT_FORWARD_LOG 2>&1 & \
	PORT_FORWARD_PID=$$!; \
	trap "kill $$PORT_FORWARD_PID 2>/dev/null || true; rm -f $$PORT_FORWARD_LOG" EXIT INT TERM; \
	echo "Port-forward started (PID: $$PORT_FORWARD_PID), waiting for it to be ready..."; \
	sleep 2; \
	if ! kill -0 $$PORT_FORWARD_PID 2>/dev/null; then \
		echo "ERROR: Port-forward process died immediately."; \
		echo "Port-forward logs:"; \
		cat $$PORT_FORWARD_LOG 2>/dev/null || echo "(no logs available)"; \
		echo ""; \
		if grep -q "address already in use\|bind.*already in use" $$PORT_FORWARD_LOG 2>/dev/null; then \
			echo "Port $$PORT_FORWARD_PORT is already in use. Try:"; \
			echo "  CDI_UPLOAD_PORT=18444 make -f Makefile.kubevirt upload-kairos-image"; \
		elif grep -q "error\|Error\|ERROR\|failed\|Failed\|FAILED" $$PORT_FORWARD_LOG 2>/dev/null; then \
			echo "Port-forward error detected. Check logs above."; \
		fi; \
		rm -f $$PORT_FORWARD_LOG; \
		exit 1; \
	fi; \
	echo "Port-forward process is running. Verifying connection..."; \
	MAX_WAIT=8; \
	WAITED=0; \
	PORT_READY=false; \
	while [ $$WAITED -lt $$MAX_WAIT ]; do \
		if ! kill -0 $$PORT_FORWARD_PID 2>/dev/null; then \
			echo "ERROR: Port-forward process died during wait."; \
			echo "Port-forward logs:"; \
			cat $$PORT_FORWARD_LOG 2>/dev/null || echo "(no logs available)"; \
			rm -f $$PORT_FORWARD_LOG; \
			exit 1; \
		fi; \
		if command -v nc >/dev/null 2>&1; then \
			if nc -z localhost $$PORT_FORWARD_PORT 2>/dev/null; then \
				echo "Port-forward is ready (port $$PORT_FORWARD_PORT is listening)"; \
				PORT_READY=true; \
				break; \
			fi; \
		elif command -v timeout >/dev/null 2>&1 && command -v bash >/dev/null 2>&1; then \
			if timeout 1 bash -c "echo > /dev/tcp/localhost/$$PORT_FORWARD_PORT" 2>/dev/null; then \
				echo "Port-forward is ready (port $$PORT_FORWARD_PORT is listening)"; \
				PORT_READY=true; \
				break; \
			fi; \
		else \
			echo "Cannot verify port (nc/timeout not available), assuming ready after delay..."; \
			sleep 2; \
			PORT_READY=true; \
			break; \
		fi; \
		sleep 1; \
		WAITED=$$((WAITED + 1)); \
	done; \
	if [ "$$PORT_READY" != "true" ]; then \
		echo "WARNING: Could not verify port-forward is ready, but proceeding anyway..."; \
		echo "If upload fails, check port-forward logs: cat $$PORT_FORWARD_LOG"; \
	fi; \
	UPLOADPROXY_URL="https://localhost:$$PORT_FORWARD_PORT"; \
	echo "Upload proxy URL (via port-forward): $$UPLOADPROXY_URL"; \
	export PATH=$$PATH:$(BIN_DIR); \
	echo "Starting upload with virtctl (this will create DataVolume and upload pod automatically)..."; \
	echo "Command: $$VIRTCTL_CMD image-upload dv $(KAIROS_IMAGE_NAME)-upload --size=20Gi --access-mode=ReadWriteOnce --image-path=$$IMAGE_FILE --uploadproxy-url=$$UPLOADPROXY_URL --insecure --force-bind --wait-secs=300"; \
	if ! $$VIRTCTL_CMD image-upload \
		dv $(KAIROS_IMAGE_NAME)-upload \
		--size=20Gi \
		--access-mode=ReadWriteOnce \
		--image-path="$$IMAGE_FILE" \
		--uploadproxy-url=$$UPLOADPROXY_URL \
		--insecure \
		--force-bind \
		--wait-secs=300; then \
		echo ""; \
		echo "ERROR: virtctl image-upload failed."; \
		echo "Checking DataVolume status..."; \
		kubectl get datavolume $(KAIROS_IMAGE_NAME)-upload -n default -o yaml 2>/dev/null | grep -A 20 "status:" || echo "DataVolume not found."; \
		echo ""; \
		echo "Checking for upload pods..."; \
		kubectl get pods -n default | grep "cdi-upload" | grep "$(KAIROS_IMAGE_NAME)" || echo "No upload pods found."; \
		echo ""; \
		echo "Checking PVC status..."; \
		kubectl get pvc $(KAIROS_IMAGE_NAME)-upload -n default -o yaml 2>/dev/null | grep -A 10 "status:" || echo "PVC not found."; \
		echo ""; \
		echo "Checking events..."; \
		kubectl get events -n default --field-selector involvedObject.name=$(KAIROS_IMAGE_NAME)-upload --sort-by='.lastTimestamp' | tail -10 || true; \
		kill $$PORT_FORWARD_PID 2>/dev/null || true; \
		rm -f $$PORT_FORWARD_LOG; \
		exit 1; \
	fi; \
	kill $$PORT_FORWARD_PID 2>/dev/null || true; \
	wait $$PORT_FORWARD_PID 2>/dev/null || true; \
	rm -f $$PORT_FORWARD_LOG; \
	echo ""; \
	echo "✓ Image upload completed successfully!"; \
	echo "DataVolume $(KAIROS_IMAGE_NAME)-upload is ready for use."'
	@echo "Kairos image uploaded ✓"

##@ Kairos CAPI Provider

.PHONY: install-cert-manager
install-cert-manager: ## Install cert-manager for webhook certificates
	@echo "Installing cert-manager..."
	@kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.yaml || \
	{ echo "Warning: Failed to install cert-manager. It may already be installed."; }
	@echo "Waiting for cert-manager to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager || true
	@kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager-webhook || true
	@kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager-cainjector || true
	@echo "cert-manager installed ✓"

.PHONY: build-kairos-provider-image
build-kairos-provider-image: ## Build and load Kairos CAPI Provider Docker image into Kind
	@echo "Building Kairos CAPI Provider image..."
	@$(MAKE) -f Makefile docker-build IMG=$(KAIROS_CAPI_IMG)
	@echo "Loading image into Kind cluster..."
	@kind load docker-image $(KAIROS_CAPI_IMG) --name $(KIND_CLUSTER_NAME)
	@echo "Kairos CAPI Provider image built and loaded ✓"

.PHONY: install-kairos-provider
install-kairos-provider: install-cert-manager build-kairos-provider-image ## Install Kairos CAPI Provider on the kind cluster
	@echo "Installing Kairos CAPI Provider..."
	@kubectl apply -k config/namespace
	@kubectl apply -k config/crd
	@kubectl apply -k config/rbac
	@kubectl apply -k config/certmanager
	@echo "Waiting for webhook certificate to be created..."
	@bash -c '\
		timeout=120; \
		while [ $$timeout -gt 0 ]; do \
			if kubectl get secret kairos-capi-webhook-server-cert -n kairos-capi-system >/dev/null 2>&1; then \
				cert_status=$$(kubectl get certificate kairos-capi-webhook-server-cert -n kairos-capi-system -o jsonpath="{.status.conditions[?(@.type==\"Ready\")].status}" 2>/dev/null || echo "False"); \
				if [ "$$cert_status" = "True" ]; then \
					echo "✓ Webhook certificate is ready"; \
					break; \
				fi; \
			fi; \
			echo -n "."; \
			sleep 2; \
			timeout=$$((timeout - 2)); \
		done; \
		echo ""; \
		if [ $$timeout -le 0 ]; then \
			echo "Warning: Webhook certificate not ready. Check cert-manager:"; \
			kubectl get certificate kairos-capi-webhook-server-cert -n kairos-capi-system -o yaml 2>/dev/null | grep -A 5 "status:" || true; \
		fi'
	@kubectl apply -k config/webhook
	@echo "Waiting for cert-manager CA injector to inject CA bundle into webhook..."
	@bash -c '\
		timeout=60; \
		while [ $$timeout -gt 0 ]; do \
			ca_bundle=$$(kubectl get mutatingwebhookconfiguration mutating-webhook-configuration -o jsonpath="{.webhooks[0].clientConfig.caBundle}" 2>/dev/null || echo ""); \
			if [ -n "$$ca_bundle" ] && [ "$$ca_bundle" != "null" ]; then \
				echo "✓ CA bundle injected into webhook"; \
				break; \
			fi; \
			echo -n "."; \
			sleep 2; \
			timeout=$$((timeout - 2)); \
		done; \
		echo ""; \
		if [ $$timeout -le 0 ]; then \
			echo "Warning: CA bundle not injected. Webhook may fail. Check cert-manager CA injector logs."; \
		fi'
	@kubectl apply -k config/manager
	@echo "Waiting for Kairos CAPI Provider to be ready..."
	@kubectl wait --for=condition=Available --timeout=300s -n kairos-capi-system deployment/kairos-capi-controller-manager || true
	@echo "Kairos CAPI Provider installed ✓"

.PHONY: uninstall-kairos-provider
uninstall-kairos-provider: ## Uninstall Kairos CAPI Provider from the kind cluster
	@echo "Uninstalling Kairos CAPI Provider..."
	@kubectl delete -k config/manager || true
	@kubectl delete -k config/webhook || true
	@kubectl delete -k config/certmanager || true
	@kubectl delete -k config/rbac || true
	@kubectl delete -k config/crd || true
	@kubectl delete -k config/namespace || true
	@echo "Kairos CAPI Provider uninstalled ✓"

##@ Cleanup

.PHONY: clean
clean: ## Clean up work directories and temporary files
	@echo "Cleaning up work directories..."
	@rm -rf $(WORK_DIR)
	@echo "Cleanup complete ✓"

.PHONY: clean-all
clean-all: delete-kind-cluster clean ## Clean up everything including the kind cluster
	@echo "Full cleanup complete ✓"

##@ Status

.PHONY: status
status: ## Show status of all components
	@echo "=== Kind Cluster Status ==="
	@kind get clusters | grep -q "^$(KIND_CLUSTER_NAME)$$" && echo "✓ Kind cluster '$(KIND_CLUSTER_NAME)' exists" || echo "✗ Kind cluster '$(KIND_CLUSTER_NAME)' not found"
	@echo ""
	@echo "=== Calico CNI Status ==="
	@kubectl get deployments -n kube-system calico-kube-controllers 2>/dev/null | grep -q calico && echo "✓ Calico installed" || echo "✗ Calico not installed"
	@echo ""
	@echo "=== KubeVirt Status ==="
	@kubectl get kubevirt -n kubevirt 2>/dev/null && echo "✓ KubeVirt installed" || echo "✗ KubeVirt not installed"
	@echo ""
	@echo "=== Cluster API Status ==="
	@kubectl get deployments -n capi-system 2>/dev/null | grep -q capi && echo "✓ CAPI installed" || echo "✗ CAPI not installed"
	@echo ""
	@echo "=== CAPK Status ==="
	@kubectl get deployments -n capk-system 2>/dev/null | grep -q capk && echo "✓ CAPK installed" || echo "✗ CAPK not installed"
	@echo ""
	@echo "=== CDI Status ==="
	@kubectl get deployments -n cdi 2>/dev/null | grep -q cdi && echo "✓ CDI installed" || echo "✗ CDI not installed"
	@echo ""
	@echo "=== Kairos CAPI Provider Status ==="
	@kubectl get deployments -n kairos-capi-system 2>/dev/null | grep -q kairos-capi && echo "✓ Kairos CAPI Provider installed" || echo "✗ Kairos CAPI Provider not installed"
	@echo ""
	@echo "=== Kairos Image Status ==="
	@if [ -f "$(KAIROS_IMAGE_FILE)" ]; then \
		echo "✓ Kairos image found: $(KAIROS_IMAGE_FILE)"; \
		ls -lh $(KAIROS_IMAGE_FILE); \
	else \
		echo "✗ Kairos image not found: $(KAIROS_IMAGE_FILE)"; \
		if [ -d "$(OSBUILDER_DIR)/build" ]; then \
			echo "Available files:"; \
			ls -lh $(OSBUILDER_DIR)/build/ 2>/dev/null || echo "Build directory is empty."; \
		fi; \
	fi
	@echo ""
	@echo "=== OSArtifact Status ==="
	@kubectl get osartifact $(KAIROS_IMAGE_NAME) -n default 2>/dev/null && echo "✓ OSArtifact exists" || echo "✗ OSArtifact not found"
	@echo ""
	@echo "=== PVC Status ==="
	@kubectl get pvc $(KAIROS_IMAGE_NAME) -n default 2>/dev/null && echo "✓ PVC exists" || echo "✗ PVC not found"

##@ Development

.PHONY: dev-deploy
dev-deploy: ## Deploy local development build of Kairos CAPI Provider
	@echo "Building and deploying local development build..."
	@$(MAKE) -f Makefile docker-build IMG=$(REGISTRY)/kairos-capi:dev
	@kind load docker-image $(REGISTRY)/kairos-capi:dev --name $(KIND_CLUSTER_NAME)
	@cd config/manager && kustomize edit set image controller=$(REGISTRY)/kairos-capi:dev
	@kustomize build config/default | kubectl apply -f -
	@echo "Development build deployed ✓"

.PHONY: create-sample-cluster
create-sample-cluster: ## Create a sample cluster manifest for KubeVirt
	@echo "Creating sample cluster manifest..."
	@mkdir -p config/samples/capk
	@bash hack/create-sample-cluster.sh

.PHONY: test-control-plane
test-control-plane: create-sample-cluster ## Create a test cluster and verify machines are created
	@echo "Verifying CAPK CRDs are installed and established..."
	@bash -c '\
		for crd in kubevirtclusters.infrastructure.cluster.x-k8s.io kubevirtmachinetemplates.infrastructure.cluster.x-k8s.io kubevirtmachines.infrastructure.cluster.x-k8s.io; do \
			if ! kubectl get crd $$crd >/dev/null 2>&1; then \
				echo "Error: CRD $$crd not found. Make sure '\''make -f Makefile.kubevirt install-capi'\'' completed successfully."; \
				exit 1; \
			fi; \
			established=$$(kubectl get crd $$crd -o jsonpath="{.status.conditions[?(@.type==\"Established\")].status}" 2>/dev/null || echo "False"); \
			if [ "$$established" != "True" ]; then \
				echo "Warning: CRD $$crd is not established yet. Waiting..."; \
				kubectl wait --for=condition=Established --timeout=60s crd/$$crd || \
				{ echo "Error: CRD $$crd failed to become established."; exit 1; }; \
			fi; \
		done; \
		echo "✓ All CAPK CRDs are established"'
	@echo "Creating test cluster..."
	@echo "Deleting existing immutable resources if they exist..."
	@kubectl delete kubevirtmachinetemplate kairos-control-plane-template -n default --ignore-not-found=true 2>/dev/null || true
	@kubectl apply -f config/samples/capk/kairos_cluster_k0s_single_node.yaml
	@echo "Waiting for cluster to be provisioned..."
	@bash -c '\
		timeout=600; \
		while [ $$timeout -gt 0 ]; do \
			phase=$$(kubectl get cluster kairos-cluster -n default -o jsonpath="{.status.phase}" 2>/dev/null || echo "Pending"); \
			if [ "$$phase" = "Provisioned" ]; then \
				echo "✓ Cluster is provisioned"; \
				break; \
			fi; \
			echo -n "."; \
			sleep 5; \
			timeout=$$((timeout - 5)); \
		done; \
		echo ""; \
		if [ $$timeout -le 0 ]; then \
			echo "Warning: Cluster provisioning timed out. Current status:"; \
			kubectl get cluster kairos-cluster -n default -o yaml | grep -A 10 "status:" || true; \
		fi'
	@echo ""
	@echo "=== Cluster Status ==="
	@kubectl get cluster kairos-cluster -n default
	@echo ""
	@echo "=== Control Plane Status ==="
	@kubectl get kairoscontrolplane kairos-control-plane -n default
	@echo ""
	@echo "=== Machine Status ==="
	@kubectl get machines -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster
	@echo ""
	@echo "=== KubeVirt VM Status ==="
	@kubectl get vms -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster
	@echo ""
	@echo "=== Pods Status ==="
	@kubectl get pods -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster
	@echo ""
	@echo "Test cluster created. Check status above to verify machines are being created."

.PHONY: test-cluster-status
test-cluster-status: ## Show status of the test cluster
	@echo "=== Cluster Status ==="
	@kubectl get cluster kairos-cluster -n default 2>/dev/null || echo "Cluster not found"
	@echo ""
	@echo "=== Control Plane Status ==="
	@kubectl get kairoscontrolplane kairos-control-plane -n default 2>/dev/null || echo "Control plane not found"
	@echo ""
	@echo "=== Machine Status ==="
	@kubectl get machines -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster 2>/dev/null || echo "No machines found"
	@echo ""
	@echo "=== KubeVirt VM Status ==="
	@kubectl get vms -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster 2>/dev/null || echo "No VMs found"
	@echo ""
	@echo "=== Pods Status ==="
	@kubectl get pods -n default -l cluster.x-k8s.io/cluster-name=kairos-cluster 2>/dev/null || echo "No pods found"
	@echo ""
	@echo "=== Recent Events ==="
	@kubectl get events -n default --field-selector involvedObject.name=kairos-cluster --sort-by='.lastTimestamp' | tail -10 || true

.PHONY: delete-test-cluster
delete-test-cluster: ## Delete the test cluster
	@echo "Deleting test cluster..."
	@kubectl delete -f config/samples/capk/kairos_cluster_k0s_single_node.yaml --ignore-not-found=true || true
	@echo "Waiting for resources to be deleted..."
	@bash -c '\
		timeout=120; \
		while [ $$timeout -gt 0 ]; do \
			if ! kubectl get cluster kairos-cluster -n default >/dev/null 2>&1; then \
				echo "✓ Cluster deleted"; \
				break; \
			fi; \
			echo -n "."; \
			sleep 2; \
			timeout=$$((timeout - 2)); \
		done; \
		echo ""'
	@echo "Test cluster deleted ✓"
